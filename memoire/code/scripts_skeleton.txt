# SQUELETTE DES SCRIPTS DU SYSTÃˆME

ğŸ“„ agentique.Semi.agent_Semi (D:\rag_personnel\agentique\Semi\agent_Semi.py)
  class AgentSemi(AgentBase):
    def __init__(self, get_cache=None, get_lock=None, socketio=None):
    def _initialiser_outils_systeme(self):
    def _initialiser_moteurs(self):
    def _initialiser_sous_agents(self):
      """Initialise les agents cognitifs avec injection de dÃ©pendances.
L'ordre est critique pour les dÃ©pendances circulaires."""
    def _initialiser_rag_code(self):
      """Initialise l'adaptateur de recherche de code (Optionnel)."""
    def _setup_callbacks_viewer(self):
      """Configure le callback pour le Prompt Viewer (SocketIO)."""
    def _initialiser_etat_session(self):
      """Initialise les variables d'Ã©tat de session."""
    def _lancer_processus_demarrage(self):
      """Lance les processus de gouvernance, continuitÃ© et maintenance."""
    def penser(self, prompt: str, interaction_id: str=None, session_id: str=None, message_turn: int=None, stream: bool=False, search_mode: str='auto', historique_brut: Optional[List[str]]=None, enable_thinking: bool=False):
      """GÃ©nÃ¨re une rÃ©ponse avec monitoring de performance en temps rÃ©el, orchestrant
le pipeline cognitif d'AgentSemi."""
    def _gerer_commandes_systeme(self, prompt: str, stream: bool) -> Optional[Dict]:
      """[ATOME] GÃ¨re les commandes systÃ¨me (+1, -1) et les protocoles (!!!).
Si une action coupe le flux normal, retourne immÃ©diatement le rÃ©sultat (yield)."""
    def _handle_forced_search(self, prompt: str, search_mode: str) -> Optional[Any]:
      """GÃ¨re le mode de recherche forcÃ©e (Web uniquement).
Redirige vers le module Deep Research de l'AgentRecherche."""
    def _enqueteur_autonome(self, prompt: str, intention: ResultatIntention) -> List[str]:
      """DÃ©cide SI une enquÃªte est nÃ©cessaire, et si oui, l'exÃ©cute.
Combine l'intention SBERT et les mots-clÃ©s forcÃ©s."""
    def post_traitement_async(self, prompt: str, reponse: str, standard_prompt: StandardPrompt, interaction_id: str, session_id: str, message_turn: int):
      """Post-traitement asynchrone aprÃ¨s gÃ©nÃ©ration de la rÃ©ponse."""
    def _verifier_batch_au_demarrage(self):
      """VÃ©rifie si le traitement batch diffÃ©rÃ© doit Ãªtre lancÃ© au dÃ©marrage.
Se dÃ©clenche si le dernier run date de plus de 45h ou n'existe pas."""
    def _lancer_batch_async(self):
      """Lance le traitement batch (consolidation mÃ©moire) dans un thread sÃ©parÃ©.
AppelÃ© par _verifier_batch_au_demarrage."""
    def consulter_architecture_et_code(self, question: str) -> str:
      """Outil critique : Ã€ utiliser dÃ¨s que tu dois rÃ©pondre Ã  une question sur 
le fonctionnement interne, le code, les fichiers ou l'architecture du projet.
Permet de lire le code source rÃ©el du projet.

Args:
    question (str): La question technique prÃ©cise (ex: "Comment fonctionne agent_Memoire ?")

Returns:
    str: Un rÃ©sumÃ© contextuel contenant les bouts de code pertinents."""
    def _rebuild_faiss_code_index(self):
      """Reconstruit l'index FAISS du code aprÃ¨s ajout de nouveaux artefacts.
Lit le fichier code_chunks.jsonl et crÃ©e des objets ContexteCode robustes."""
    def _exec_update_system_summary(self, new_content: str) -> str:
      """[MUSCLE] Ã‰crase le fichier etat_systeme_resume.md.
FORCE la date de mise Ã  jour systÃ¨me rÃ©elle."""
    def _detecter_et_executer_function_call(self, response: str) -> Optional[Dict]:
      """DÃ©tecte et exÃ©cute un function call"""
    def actualiser_resume_systeme(self):
      """Lit l'historique et le TODO (situÃ©s dans le dossier de l'agent Semi) 
et gÃ©nÃ¨re le fichier 'etat_systeme_resume.md'.
Utilise l'Auditor pour rÃ©soudre les chemins de maniÃ¨re absolue."""
    def _format_manual_context(self, manual_context: List[Dict]) -> str:
      """Formate le contexte manuel des slots en string pour agent_Parole"""
    def obtenir_etat_cognitif(self) -> Dict[str, Dict]:
      """Collecte les statistiques de tous les sous-agents pour synchronisation.

Returns:
    Dict avec les stats de chaque agent au format:
    {
        "AgentMemoire": {
            "appels_total": int,
            "erreurs_total": int,
            "temps_moyen_ms": float,
            "stats_specifiques": dict
        },
        ...
    }"""

ğŸ“„ agentique.Semi.classes_cognitives.intention_detector (D:\rag_personnel\agentique\Semi\classes_cognitives\intention_detector.py)
  class ClassifierHead(torch.nn.Module):
    """Classe PyTorch qui doit matcher exactement le modÃ¨le du script d'entraÃ®nement.
(SBERT -> Embedding -> MLP 256 -> nb_labels)"""
    def __init__(self, emb_dim: int, nb_labels: int):
    def forward(self, x):
  class IntentionDetector(AgentBase):
    """IntentionDetector v4 â€” SBERT + 3 classifieurs PyTorch
PilotÃ© EXCLUSIVEMENT par le YAML.
ZÃ©ro hardcode."""
    def __init__(self):
    def _load_classifier_weights(self):
    def _construire_contexte(self, prompt: str, historique: Optional[List[str]]):
    def intention_detector(self, prompt: str, historique_brut: Optional[List[str]]=None) -> ResultatIntention:

ğŸ“„ agentique.Semi.outils_de_test.intention_detector_label_map_generator (D:\rag_personnel\agentique\Semi\outils_de_test\intention_detector_label_map_generator.py)
  def enum_to_dict(enum_cls):
  def main():

ğŸ“„ agentique.Semi.outils_de_test.labo_architecte (D:\rag_personnel\agentique\Semi\outils_de_test\labo_architecte.py)

ğŸ“„ agentique.Semi.outils_de_test.test_diagnostic_semi (D:\rag_personnel\agentique\Semi\outils_de_test\test_diagnostic_semi.py)

ğŸ“„ agentique.Semi.outils_de_test.test_imports_agent_semi (D:\rag_personnel\agentique\Semi\outils_de_test\test_imports_agent_semi.py)
  def test_file_existence():
    """Teste l'existence des fichiers Python"""
  def test_individual_imports():
    """Teste chaque import individuellement"""
  def test_agent_semi_import():
    """Teste l'import d'AgentSemi complet"""
  def test_agent_semi_initialization():
    """Teste l'initialisation d'AgentSemi"""
  def main():
    """Fonction principale de test"""

ğŸ“„ agentique.base.META_agent (D:\rag_personnel\agentique\base\META_agent.py)
  class MemoireTravailRAM():
    """Memoire RAM - Version complÃ¨te avec toutes les mÃ©thodes"""
    def __new__(cls):
    def ajouter_travail(self, item: dict) -> bool:
    def recuperer_travail(self) -> list[dict]:
    def remplacer_travail(self, nouveaux_items: list[dict]) -> bool:
    def evaluer_travail(self, items_valides: list[dict]) -> bool:
      """COPIÃ‰ TEL QUEL depuis AgentMemoire"""
    def obtenir_stats_travail(self) -> dict:
      """Retourne les statistiques de la mÃ©moire RAM."""
    def vider_travail(self) -> int:
  class MetaAgent(type):
    """MÃ©taclasse qui injecte les outils ET le monitoring automatique."""
    def __call__(cls, *args, **kwargs):
    def @staticmethod
      """CrÃ©e un wrapper qui loggue les appels et les erreurs automatiquement."""
    def @staticmethod
    def @staticmethod
  class AgentBase():
    """Classe de base optionnelle pour les agents
HÃ©riter de cette classe applique automatiquement MetaAgent"""
    def __init__(self, nom_agent: str=None):
      """Initialisation de base
Le nom sera extrait automatiquement si non fourni"""

ğŸ“„ agentique.base.auditor_base (D:\rag_personnel\agentique\base\auditor_base.py)
  class StandardsAgents():
    """Standards RÃ‰ELS extraits des agents existants
Pas de suggestions, uniquement ce qui existe"""
  class AuditorBase():
    """Classe d'audit - NE CRÃ‰E AUCUN DOSSIER
VÃ©rifie seulement l'existence"""
    def __init__(self, nom_agent: str):
    def get_config(self) -> Dict[str, Any]:
      """Retourne la config pour cet agent"""
    def get_path(self, path_type: str, nom_agent: Optional[str]=None) -> Optional[str]:
      """CORRIGÃ‰ : RÃ©cupÃ¨re un chemin configurÃ© en utilisant la structure StandardsAgents."""
    def chemin_existe(self, type_path: str) -> bool:
      """VÃ©rifie si un chemin existe SANS le crÃ©er"""
    def get_param(self, nom_param: str, defaut: Any=None) -> Any:
      """RÃ©cupÃ¨re un paramÃ¨tre de configuration"""
    def get_formats_entree(self) -> List[str]:
      """Retourne les formats d'entrÃ©e acceptÃ©s"""
    def get_formats_sortie(self) -> List[str]:
      """Retourne les formats de sortie produits"""
    def get_stats_specifiques(self) -> List[str]:
      """Retourne la liste des stats spÃ©cifiques Ã  tracker"""
    def valider_format_entree(self, data: Any) -> bool:
      """Valide le format d'entrÃ©e"""
    def valider_format_sortie(self, data: Any) -> bool:
      """Valide le format de sortie"""
    def valider_echange(self, data: Any, agent_destination: str) -> bool:
      """Valide un Ã©change de donnÃ©es vers un autre agent

Args:
    data: DonnÃ©es Ã  envoyer
    agent_destination: Nom de l'agent destinataire
    
Returns:
    True si l'Ã©change est valide"""
  class AuditorGlobal():
    """Singleton pour accÃ¨s global aux standards"""
    def __new__(cls):

ğŸ“„ agentique.base.cognitive_logger (D:\rag_personnel\agentique\base\cognitive_logger.py)
  class CognitiveLogger():
    def __init__(self, nom_agent=None, session_id=None, console_output=True, auditor=None):
      """CORRECTION: Utiliser l'auditor pour obtenir les chemins de logs"""
    def _log_to_handlers(self, level, console_msg, json_msg, exc_info=False):
      """CORRECTION: Gestion propre des logs avec le logger standard Python"""
    def log_interaction(self, role, message, context='main'):
    def log_api_call(self, engine, prompt, response_json):
    def log_thought(self, thought_text):
    def log_error(self, error_msg, exc_info=False):
    def log_warning(self, warning_msg):
      """MÃ©thode ajoutÃ©e pour la compatibilitÃ©"""
    def info(self, message):
      """CompatibilitÃ© avec logging standard"""
    def _now(self):
    def set_correlation_id(self):
      """GÃ©nÃ¨re un ID de corrÃ©lation unique"""
    def signal_gouvernance(self, message: str):
      """Log un Ã©vÃ©nement de gouvernance de haute prioritÃ© (ex: '!!!').
Nous utilisons log_error en interne pour lui donner une haute visibilitÃ©."""

ğŸ“„ agentique.base.config_paths (D:\rag_personnel\agentique\base\config_paths.py)
  def find_project_root(marker: str='.project_root') -> Path:
    """Trouve la racine du projet en cherchant un fichier marqueur."""

ğŸ“„ agentique.base.contrats_interface (D:\rag_personnel\agentique\base\contrats_interface.py)
  class FlexibleEnum(Enum):
    def @classmethod
  class Sujet(EnumFlexible):
  class Action(EnumFlexible):
  class Categorie(EnumFlexible):
  class TypeMemoire(Enum):
    """Types de mÃ©moire"""
  class SearchMode(Enum):
    """Modes de recherche pilotÃ©s EXCLUSIVEMENT par l'interface frontend.
L'IA n'a pas le droit d'initier une recherche d'elle-mÃªme."""
  class CustomJSONEncoder(json.JSONEncoder):
    """Encodeur universel pour Dataclasses et Enums."""
    def default(self, o):
  class MetadataFichier():
    """PERSISTANT : Infos contextuelles conservÃ©es dans l'ARCHIVE.
Contient TOUT ce qui n'est pas le texte de la conversation."""
  class MetadataPipeline():
    """VOLATILE : Infos de performance et de debug.
EnvoyÃ© dans les logs de Semi, ne pollue pas la mÃ©moire long terme."""
  class Souvenir():
    """ATOME 2 : Sortie unifiÃ©e de l'AgentRecherche.
Le plus petit dÃ©nominateur commun de la mÃ©moire."""
  class ModificateursCognitifs():
    """ATOME 3 : Configuration venant de l'UI"""
  class ResultatIntention():
    """SORTIE DE : IntentionDetector
Ce qu'il rend au systÃ¨me aprÃ¨s analyse."""
  class ResultatRecherche():
    """SORTIE DE : AgentRecherche
Ce qu'il rend aprÃ¨s avoir fouillÃ© (Whoosh/Vectoriel)."""
  class ResultatRechercheWeb():
  class ResultatContexte():
    """SORTIE DE : AgentContexte
Ce qu'il rend aprÃ¨s avoir triÃ© et organisÃ© la mÃ©moire."""
  class ResultatJuge():
    """SORTIE DE : AgentJuge
Ce qu'il rend aprÃ¨s avoir Ã©valuÃ© la rÃ©ponse."""
  class Interaction():
    """L'Objet final sauvegardÃ© sur le disque (JSON)."""
  class ContexteCode():
    """ATOME CODE : Format standard pour injection de contexte code.
Structure sÃ©mantique remplaÃ§ant les chunks textuels bruts.
Compatible avec le systÃ¨me +1/-1 de Semi."""
  class AnalyseContenu():
    """Structure dÃ©taillÃ©e de l'analyse d'un code (AST)"""
  class ArtefactCode():
    """ATOME : Objet de transit pour un snippet ou fichier analysÃ©.
C'est ce que produit RechercheCodeExtractor."""
  class StandardPrompt():
    """Recette 1 : Chat Standard.
Structure aplatie pour un accÃ¨s direct aux composants du prompt."""
  class NewChatPrompt():
    """Premier message d'un nouveau chat.
UtilisÃ© lorsque Semi dÃ©tecte un salut ou qu'une commande systÃ¨me
dÃ©clenche un redÃ©marrage cognitif du dialogue.

Ce prompt remplace le contexte normal : il injecte uniquement :
- les rÃ¨gles actives
- l'historique rÃ©cent condensÃ©
- le rÃ©sumÃ© systÃ¨me global"""
  class WebSearchPrompt():
    """Recette 2 : Recherche Web ForcÃ©e.
Contient uniquement la query et les rÃ©sultats bruts."""
  class ProtocolePrompt():
    """Recette 4 : Protocole d'Intervention ALERTE (!!!).
Remplace le System Prompt standard par le protocole de sÃ©curitÃ©."""
  class StatsBase():
    def incrementer_appel(self) -> None:
    def incrementer_erreur(self) -> None:
    def ajouter_stat_specifique(self, nom: str, valeur_initiale: Any=0) -> None:
    def incrementer_stat_specifique(self, nom: str, increment: int=1) -> None:
    def definir_stat_specifique(self, nom: str, valeur: Any) -> None:
      """DÃ©finit ou remplace la valeur d'une statistique spÃ©cifique."""
    def obtenir_stat_specifique(self, nom: str, defaut: Any=None) -> Any:
      """RÃ©cupÃ¨re la valeur d'une statistique spÃ©cifique."""
    def existe_stat_specifique(self, nom: str) -> bool:
      """VÃ©rifie si une statistique spÃ©cifique existe."""
    def obtenir_statistiques(self) -> Dict[str, Any]:
    def obtenir_resume(self) -> str:
    def reinitialiser(self) -> None:
    def @property

ğŸ“„ agentique.base.gardien_projet (D:\rag_personnel\agentique\base\gardien_projet.py)
  class GardienHandler(FileSystemEventHandler):
    def __init__(self):
    def charger_project_map(self):
      """Charge dynamiquement la liste des fichiers Ã  surveiller depuis project_map.json."""
    def on_modified(self, event):
    def auditer_si_necessaire(self, file_path: Path):
      """DÃ©clenche l'audit pour les fichiers critiques"""
  class GardienProjet():
    def __init__(self):
    def synchroniser_stats_periodique(self):
      """Synchronise les stats via l'API backend toutes les 5 minutes"""
    def start(self):
    def stop(self):

ğŸ“„ agentique.base.monitoring.tracer (D:\rag_personnel\agentique\base\monitoring\tracer.py)
  class AgentTracer():
    """Gestionnaire de tracing pour les agents"""
    def __init__(self, logger, actif: bool=True):
      """Args:
    logger: Instance de CognitiveLogger (gardÃ© pour compatibilitÃ©)
    actif: Active/dÃ©sactive le tracing"""
    def trace_call(self, func: Callable) -> Callable:
      """Decorator qui trace automatiquement les appels de fonction

Usage:
    @tracer.trace_call
    def ma_fonction(self, arg1, arg2):
        pass"""
    def activer(self):
      """Active le tracing"""
    def desactiver(self):
      """DÃ©sactive le tracing"""

ğŸ“„ agentique.base.trace_request (D:\rag_personnel\agentique\base\trace_request.py)
  def trace_correlation_id(correlation_id):
    """Affiche tous les logs d'une requÃªte spÃ©cifique"""

ğŸ“„ agentique.base.utils_text (D:\rag_personnel\agentique\base\utils_text.py)
  class EnumFlexible(Enum):
    """Classe MÃ¨re pour TOUS tes Enums (Sujet, Action, Categorie).
Elle permet de trouver une valeur peu importe les accents."""
    def @classmethod
  def standardiser(texte):
    """Fonction ULTIME pour nettoyer du texte.
Transforme: "GÃ©nÃ©ral", "GENERAL", "General", " gEnErAl " 
En: "general""""
  def comparer(texte1, texte2):
    """Utilise Ã§a partout Ã  la place de '=='
Renvoie True si les textes sont Ã©quivalents (sans accents/casse)"""

ğŸ“„ agentique.base.version_tracker (D:\rag_personnel\agentique\base\version_tracker.py)
  class VersionTracker():
    def __init__(self, agent_code_extractor):
      """Initialise le tracker.
Il garde maintenant un registre interne des codes suggÃ©rÃ©s pour un accÃ¨s instantanÃ©."""
    def enregistrer_nouveau_code(self, bloc_code: Dict[str, Any], chemin_source: Path):
      """CORRECTION MAJEURE : MÃ©thode active pour enregistrer un nouveau code dÃ¨s sa crÃ©ation.
Doit Ãªtre appelÃ©e par AgentSemi."""
    def marquer_valide(self, hash_code: str, commentaire: str='ValidÃ© par +1') -> bool:
      """CORRECTION MAJEURE : Marque un code comme valide en utilisant le registre interne.
C'est maintenant beaucoup plus rapide et fiable."""
    def obtenir_dernier_valide(self, pattern: str='') -> Optional[Dict]:
      """RÃ©cupÃ¨re la derniÃ¨re version validÃ©e (inchangÃ©)."""
    def _load_index(self) -> Dict:
    def _save_index(self):

ğŸ“„ agentique.sous_agents_gouvernes.agent_Auditor.agent_Auditor (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Auditor\agent_Auditor.py)
  class ContractComplianceVisitor(ast.NodeVisitor):
    """VÃ©rifie que les instanciations de Dataclasses respectent la dÃ©finition officielle."""
    def __init__(self, definitions_contrats: Dict[str, Set[str]]):
    def visit_Call(self, node):
      """DÃ©tecte : MaClasse(arg1=..., arg2=...)"""
  class FunctionHygieneVisitor(ast.NodeVisitor):
    """Analyse l'hygiÃ¨ne interne des fonctions.
[MODIFIE] : Ne vÃ©rifie plus la complexitÃ© (Refactor suggÃ©rÃ©).
VÃ©rifie uniquement les variables mortes (Dead Code)."""
    def __init__(self):
    def visit_FunctionDef(self, node):
      """Analyse une fonction spÃ©cifique isolÃ©ment."""
  class ShadowComplianceVisitor(ast.NodeVisitor):
    """POLICE DE STANDARDISATION :
DÃ©tecte les dictionnaires manuels qui ressemblent Ã©trangement Ã  des Dataclasses existantes.
But : Forcer l'utilisation des objets standards."""
    def __init__(self, definitions_contrats: Dict[str, Set[str]]):
    def _analyser_dictionnaire(self, node_dict: ast.Dict, contexte: str):
      """Compare les clÃ©s d'un dictionnaire AST avec les dÃ©finitions officielles."""
    def visit_Return(self, node):
      """VÃ©rifie si on retourne un dictionnaire manuel au lieu d'un objet."""
    def visit_Assign(self, node):
      """VÃ©rifie si on assigne un dictionnaire manuel imitant un objet."""
  class AgentAuditor(AgentBase):
    def __init__(self):
    def _charger_config(self) -> Dict:
    def _construire_definitions_contrats(self) -> Dict[str, Set[str]]:
      """Construit un dictionnaire : { 'NomClasse': {'champ1', 'champ2'} }
C'est la SEULE source de vÃ©ritÃ©."""
    def auditer_compliance_contrats(self, fichier: Path) -> List[str]:
      """VÃ©rifie si les contrats sont correctement instanciÃ©s.
Plus besoin de whitelist."""
    def _construire_vocabulaire_contrats(self) -> Set[str]:
      """Scanne contrats_interface.py pour extraire tous les noms de champs valides.
C'est la rÃ©fÃ©rence absolue."""
    def _signaler_au_gardien(self, message: str, niveau: str):
      """Communication directe avec le Gardien si une rÃ¨gle critique est violÃ©e."""
    def auditer_hygiene_interne(self, fichier: Path) -> List[str]:
      """Nouveau module : VÃ©rifie la propretÃ© interne des fonctions (Code mort).
NOTE: Ne vÃ©rifie plus la complexitÃ© cognitive."""
    def auditer_securite_fichier(self, fichier: Path) -> List[str]:
      """VÃ©rifie les accÃ¨s disques interdits et patterns dangereux."""
    def auditer_standardisation(self, fichier: Path) -> List[str]:
      """VÃ©rifie si le code utilise bien les standards au lieu de bricoler."""
    def auditer_conformite_structurelle(self, fichier: Path) -> List[str]:
      """VÃ©rifie l'hÃ©ritage et les imports."""
    def generer_cartographie(self) -> str:
      """GÃ©nÃ¨re la map pour le LLM en respectant STRICTEMENT les exclusions du config.yaml."""
    def _charger_stats_agent(self, nom_agent_clean: str) -> Dict:
      """Charge la section 'dashboard_stats' du fichier config d'un agent.
Tente de localiser le fichier config de maniÃ¨re robuste."""
    def auditer_coherence_flux(self) -> List[str]:
      """VÃ©rifie la logique mÃ©tier : Est-ce que ce qui est produit est bien stockÃ© ?
Compare les compteurs d'appels entre le Moteur LLM et la MÃ©moire."""
    def auditer_systeme(self, mode='sanity_check') -> Dict:
      """Lance l'audit complet (SÃ©curitÃ© + Structure + Flux)."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Auditor.test_de_securite_backend (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Auditor\test_de_securite_backend.py)
  class TestPathTraversal():
    """Tests de sÃ©curitÃ© contre les attaques Path Traversal"""
    def test_path_traversal_formation_data(self, client):
      """VÃ©rifie que ../../../ ne permet pas de sortir du dossier"""
    def test_path_traversal_serve_html(self, client):
      """VÃ©rifie la route /<filename>"""
    def sanitize_filename(nom: str) -> str:
      """Nettoie un nom pour usage dans un chemin de fichier"""
    def test_sanitize_filename():
      """VÃ©rifie que les caractÃ¨res dangereux sont retirÃ©s"""
    def test_cors_origine_non_autorisee(self, client):
      """VÃ©rifie que les origines externes sont bloquÃ©es"""
    def test_rate_limiting_command(self, client):
      """VÃ©rifie que le rate limit bloque aprÃ¨s X requÃªtes"""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Contexte.agent_Contexte (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Contexte\agent_Contexte.py)
  class AgentContexte(AgentBase):
    """GÃ¨re la rÃ©cupÃ©ration et le filtrage du contexte mÃ©moire.
Orchestre AgentRecherche et formate les rÃ©sultats."""
    def __init__(self, agent_recherche: 'AgentRecherche', agent_juge: 'AgentJuge'):
    def _charger_config(self) -> Dict:
    def get_historique_chat(self) -> List[str]:
      """Retourne l'historique conversationnel stockÃ© par l'AgentContexte."""
    def mettre_a_jour_historique(self, prompt: str, reponse: str):
      """Ajoute une nouvelle interaction Ã  l'historique de session et le Tronque."""
    def get_historique_nouveau_chat(self, max_echanges: int=3) -> List[str]:
      """Gouvernance : RÃ¨gle impÃ©rative de continuitÃ©. 
RÃ©cupÃ¨re les derniers Ã©changes de la mÃ©moire persistante (via lecture du disque) 
au dÃ©but d'une nouvelle session pour assurer la continuitÃ©.

Args:
    max_echanges (int): Nombre maximal de paires P/R Ã  charger.

Returns:
    List[str]: L'historique formatÃ© comme une liste plate [P1, R1, P2, R2, ...]."""
    def recuperer_contexte_intelligent(self, resultat_intention: ResultatIntention, resultat_recherche: ResultatRecherche) -> ResultatContexte:
    def associer_regles_symboliques(self, prompt: str) -> List[str]:
      """Associe des rÃ¨gles de gouvernance basÃ©es sur des mots-clÃ©s.
Retourne une liste d'IDs (ex: ['R01_PasAnalogies'])."""
    def _detecter_tags_categories(self, prompt: str) -> List[str]:
      """DÃ©tecte si le prompt dÃ©clenche une catÃ©gorie entiÃ¨re de rÃ¨gles."""
    def recuperer_protocole_alerte(self) -> str:
      """Gouvernance : RÃ©cupÃ¨re le contenu du fichier protocole_intervention_ALERTE.md."""
    def get_historique_recent(self, limit: int=10) -> List[str]:
      """Retourne les N derniers messages de l'historique RAM."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Entraineur.agent_Entraineur (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Entraineur\agent_Entraineur.py)
  class ClassifierHead(nn.Module):
    """Architecture du rÃ©seau de neurones (Doit matcher IntentionDetector)"""
    def __init__(self, emb_dim: int, nb_labels: int):
    def forward(self, x):
  class IntentDataset(Dataset):
    """Dataset PyTorch pour SBERT"""
    def __init__(self, data, sbert_model, axe, label_map):
    def __len__(self):
    def __getitem__(self, idx):
  class AgentEntraineur(AgentBase):
    def __init__(self):
    def _charger_config_sbert(self) -> Dict:
      """Charge la config depuis le fichier de configuration du moteur MiniLLM (qui contient la section Sbert)"""
    def _fusionner_datasets(self) -> List[Dict]:
      """Fusionne tous les fichiers JSONL disponibles."""
    def _preparer_mapping_labels(self, axe: str) -> Dict[str, int]:
      """CrÃ©e le mapping Label -> ID basÃ© sur le fichier de config JSON."""
    def entrainer_sur_disque(self, epochs: int=8, learning_rate: float=0.0001):
      """Lance l'entraÃ®nement complet pour les 3 axes.
Sauvegarde les fichiers .pth."""
    def _entrainer_axe(self, axe: str, data: List[Dict], epochs: int, lr: float) -> float:
      """EntraÃ®ne un classifieur spÃ©cifique (ex: Sujet)."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Entraineur.auto_dataset_builder (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Entraineur\auto_dataset_builder.py)
  class AutoDatasetBuilder(AgentBase):
    def __init__(self):
    def _nettoyer_texte(self, texte: str) -> str:
      """Nettoyage basique : espaces, sauts de ligne excessifs."""
    def _est_qualifie(self, prompt: str, intention: Any) -> bool:
      """Quality Gate : DÃ©cide si l'interaction mÃ©rite d'Ãªtre apprise."""
    def ajouter_interaction(self, interaction: Interaction, source: str='batch') -> bool:
      """Convertit une Interaction en ligne de dataset et l'ajoute au fichier."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Entraineur.force_dataset_generation (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Entraineur\force_dataset_generation.py)
  def main():

ğŸ“„ agentique.sous_agents_gouvernes.agent_Juge.agent_Juge (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Juge\agent_Juge.py)
  class AgentJuge(AgentBase):
    def __init__(self, agent_recherche, moteur_mini_llm=None):
    def _load_config(self, config_path: str) -> Dict:
      """Charge la configuration YAML de l'agent."""
    def calculer_pertinence_semantique(self, prompt: str, souvenir_contenu: str, souvenir_titre: str, filtres_semantiques: List[Dict]) -> float:
      """Calcule la pertinence en vÃ©rifiant le contenu ET le titre."""
    def evaluer_coherence_reponse(self, contexte_rag_str: str, prompt: str, reponse: str) -> ResultatJuge:
      """Ã‰value si la rÃ©ponse est factuellement soutenue par le contexte RAG.
CORRECTIF : GÃ¨re le cas oÃ¹ le contexte est vide (Abstention)."""
    def _construire_prompt_juge(self, contexte_rag_str: str, prompt: str, reponse: str) -> str:
      """Construit le prompt systÃ¨me pour forcer le Mini-LLM Ã  agir en Juge."""
    def _extraire_json_reponse(self, reponse_brute: str) -> Dict:
    def _parser_reponse_juge(self, reponse_brute: str) -> ResultatJuge:
      """Convertit la rÃ©ponse textuelle du LLM en objet ResultatJuge structurÃ©."""
    def _mettre_a_jour_coherence_moyenne(self, nouveau_score: float):

ğŸ“„ agentique.sous_agents_gouvernes.agent_Memoire.agent_Memoire (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Memoire\agent_Memoire.py)
  class AgentMemoire(AgentBase):
    def __init__(self, agent_recherche: 'AgentRecherche', moteur_vectoriel: Optional['MoteurVectoriel']=None, root_dir: str=None, session_id: str=None):
    def sauvegarder_memoire(self, contenu: Any, type_memoire: str, nom_fichier: str) -> bool:
      """MÃ©thode gÃ©nÃ©rique pour sauvegarder du contenu (Texte ou JSON) 
dans un sous-dossier de la mÃ©moire (persistante, reflexive, etc.).
UtilisÃ©e par l'API pour l'injection manuelle et le feedback."""
    def sauvegarder_interaction_brute(self, donnee_entree: Union[Interaction, str], contenu: str=None, session_id: str=None, message_turn: int=None, metadata: Dict=None) -> bool:
      """Capture une interaction brute au format JSONL dans le dossier 'brute'.
MÃ©thode POLYMORPHE : S'adapte selon ce qu'on lui envoie."""
    def memoriser_interaction(self, interaction_element: Interaction) -> bool:
      """Sauvegarde le fichier JSON individuel dans 'historique'.
C'est ce fichier qui sera lu plus tard par le Processeur DiffÃ©rÃ©."""
    def journaliser_trace_reflexive(self, trace_markdown: str, type_erreur: str, classification: str):
    def sauvegarder_artefacts_code(self, artefacts: List[Dict]) -> bool:
      """ReÃ§oit les paquets prÃ©parÃ©s par l'Extracteur et les Ã©crit sur le disque.
Version compatible ContexteCode (Champs obligatoires)."""
    def obtenir_statistiques(self) -> Dict[str, Any]:
      """Retourne les statistiques de l'agent via le StatsManager."""
    def _charger_etat_traitement(self) -> Dict:
      """Charge ou crÃ©e un Ã©tat minimal de traitement."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Memoire.moteur_vecteur (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Memoire\moteur_vecteur.py)
  class MoteurVectoriel():
    """Moteur de mÃ©moire sÃ©mantique persistante basÃ© sur FAISS.
Chaque fragment est vectorisÃ© et indexÃ© avec ses mÃ©tadonnÃ©es."""
    def __init__(self, chemin_index: str | None=None, dim: int=384, model_name: str='all-MiniLM-L6-v2'):
    def _sauvegarder_index(self):
      """Sauvegarde l'index FAISS et les mÃ©tadonnÃ©es sur disque."""
    def _charger_index(self):
      """Recharge l'index FAISS et les mÃ©tadonnÃ©es si disponibles."""
    def ajouter_fragment(self, texte: str, meta: dict | None=None) -> None:
      """Ajoute un fragment + mÃ©tadonnÃ©es dans lâ€™index persistÃ©."""
    def rechercher(self, requete: str, top_k: int=5) -> list[dict]:
      """Recherche sÃ©mantique et renvoie [{score, meta}]."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Memoire.traitement_brute_persistante (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Memoire\traitement_brute_persistante.py)
  class ProcesseurBrutePersistante(AgentBase):
    def __init__(self, llm_engine=None):
    def _charger_etat(self) -> Dict:
    def _sauver_etat(self):
    def traiter_batch_differe(self):
      """Point d'entrÃ©e principal."""
    def _grouper_fichiers_par_session(self) -> Dict:
      """Groupe les fichiers non traitÃ©s par session_id"""
    def _analyser_session_complete(self, messages: List[Dict], session_id: str) -> List[Interaction]:
      """Envoie TOUTE la conversation au LLM et demande une sortie structurÃ©e bloc par bloc.
Assure la cohÃ©rence de l'intention sur toute la ligne."""
    def _extraire_intention_du_bloc(self, texte: str) -> ResultatIntention:
      """Parse les tags Markdown en nettoyant les crochets Ã©ventuels"""
    def _sauvegarder_resume(self, interaction: Interaction, data_brute: Dict) -> Path:
    def _indexer_resume(self, interaction: Interaction, chemin: Path):

ğŸ“„ agentique.sous_agents_gouvernes.agent_Parole.agent_Parole (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Parole\agent_Parole.py)
  class AgentParole(AgentBase):
    """AgentParole - Constructeur de Prompt.
Sa seule responsabilitÃ© est de crÃ©er le prompt ChatML final."""
    def __init__(self, agent_contexte=None, agent_semi=None, get_cache=None, get_lock=None):
    def _charger_config(self) -> dict:
      """Charge la configuration YAML spÃ©cifique Ã  AgentParole."""
    def recuperer_instruction(self, cle: str) -> str:
      """Accesseur public pour que Semi puisse logger/sauvegarder le system prompt utilisÃ©."""
    def _recuperer_scripts_skeleton(self) -> str:
      """Lit le fichier scripts_skeleton.txt gÃ©nÃ©rÃ© par l'AnalyseurCode.
Source de vÃ©ritÃ© sur la structure du projet pour le LLM."""
    def construire_prompt_llm(self, req: Union[StandardPrompt, WebSearchPrompt, ProtocolePrompt]) -> str:
      """MÃ©thode d'aiguillage pour les objets dÃ©jÃ  construits.
Note: Le 'NewChat' est gÃ©rÃ© Ã  part via prompt_premier_chat."""
    def _construire_prompt_standard(self, req: StandardPrompt) -> str:
      """Assemble le prompt pour une interaction standard en respectant le contrat."""
    def _construire_prompt_web_search(self, req: WebSearchPrompt) -> str:
      """Assemble un prompt pour la recherche Web isolÃ©e."""
    def _update_viewer(self, prompt_str, type_req):
      """Mise Ã  jour du cache pour le Prompt Viewer"""
    def _extraire_contenu_liste(self, liste_objets: List[Any]) -> List[str]:
      """Extrait le texte de Souvenirs ou retourne les strings brutes."""
    def prompt_premier_chat(self, prompt_original: str) -> str:
      """MÃ©thode tout-en-un pour le nouveau chat : 
1. RÃ©cupÃ¨re les donnÃ©es et la Config.
2. CrÃ©e l'objet NewChatPrompt (Logique).
3. Formate le texte final (Visuel)."""
    def _construire_prompt_protocole(self, req: ProtocolePrompt) -> str:
      """Construit un prompt d'urgence oÃ¹ le Protocole remplace l'identitÃ© standard."""
    def _formater_documentation(self, docs: List[Any]) -> str:
      """En-tÃªte DOCUMENTATION_UTILE"""
    def _formater_regles(self, regles: List[Any]) -> str:
      """En-tÃªte RÃˆGLES"""
    def _formater_contexte_memoire(self, souvenirs: List[Souvenir]) -> str:
      """En-tÃªte CONTEXTE MÃ‰MOIRE (Max 6 Ã©lÃ©ments).
Tente de parser le JSON pour extraire prompt/rÃ©ponse/meta."""
    def _formater_historique_inverse(self, historique: List[str]) -> str:
      """En-tÃªte HISTORIQUE DE CONVERSATION.
NumÃ©rotÃ© de 1 (RÃ©cent) Ã  6 (Vieux)."""
    def _recuperer_resume_systeme(self) -> str:
      """RÃ©cupÃ¨re le contenu de 'etat_systeme_resume.md'.
Utilise l'Auditor pour localiser le dossier de l'Agent Semi."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Parole.moteurs.moteur_llm (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Parole\moteurs\moteur_llm.py)
  class MoteurLLM(AgentBase):
    def __init__(self, perf_monitor=None):
    def _load_config(self):
    def _prepare_payload(self, prompt_text: str, stream: bool=False) -> dict:
    def generer_stream(self, prompt_text: str) -> Generator[str, None, None]:
    def generer(self, prompt_text: str) -> Dict:
      """GÃ©nÃ©ration non-streamÃ©e (standard)."""
    def @property

ğŸ“„ agentique.sous_agents_gouvernes.agent_Parole.moteurs.moteur_mini_llm (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Parole\moteurs\moteur_mini_llm.py)
  class MoteurMiniLLM(AgentBase):
    """Client HTTP pour le Mini-LLM (ex: Phi-3 sur port 8081).
Singleton conservÃ© pour la gestion du Lock inter-threads."""
    def __new__(cls, *args, **kwargs):
    def __init__(self, config_file: str='config_moteur_mini_llm.yaml'):
    def _prepare_payload(self, prompt: str, temperature: float=None, stream: bool=False) -> dict:
    def generer_stream(self, prompt: str, temperature: float=None) -> Generator[str, None, None]:
    def generer(self, prompt: str, temperature: float=None) -> Dict[str, Any]:
    def @property

ğŸ“„ agentique.sous_agents_gouvernes.agent_Parole.moteurs.verifier_chargement_modeles (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Parole\moteurs\verifier_chargement_modeles.py)
  def verifier():

ğŸ“„ agentique.sous_agents_gouvernes.agent_Recherche.agent_Recherche (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Recherche\agent_Recherche.py)
  class AgentRecherche(AgentBase):
    """AgentRecherche - Recherche performante dans la mÃ©moire.
Sortie : ResultatRecherche (Liste de Souvenirs + MÃ©tadonnÃ©es)

ImplÃ©mente une recherche performante dans la mÃ©moire avec:
- PrÃ©-filtrage rapide via Everything (es.exe)
- Recherche sÃ©mantique via Whoosh
- Gestion de la classification des interactions"""
    def __init__(self):
    def _find_everything_exe(self) -> Optional[str]:
      """Trouve Everything.exe sur le systÃ¨me"""
    def _ensure_index_exists(self):
      """VÃ©rifie ou crÃ©e l'index Whoosh"""
    def _creer_schema_whoosh(self):
      """CrÃ©e le schÃ©ma et l'index"""
    def recherche_web_profonde(self, objectif: str) -> str:
      """Lance une recherche web itÃ©rative et profonde (Deep Research).
Utilise l'outil 'RechercheWeb' injectÃ©."""
    def _definir_strategie_recherche(self, classification: Optional[ResultatIntention]) -> Dict[str, Any]:
      """DÃ©finit la stratÃ©gie de recherche en priorisant les rÃ¨gles puis les mÃ©moires gÃ©nÃ©rales."""
    def rechercher_regles_par_tag(self, tag: str) -> List[Souvenir]:
      """Scanne le dossier rÃ¨gles et retourne TOUTES les rÃ¨gles contenant le tag dans leur nom.
Ex: tag="doc" -> R_002_doc_Valider.json"""
    def rechercher_regles_par_ids(self, regles_ids: List[str]) -> List[Souvenir]:
      """RÃ©cupÃ¨re les rÃ¨gles via Everything dans un thread pour ne pas bloquer."""
    def detecter_besoin_documentation(self, prompt: str) -> List[str]:
      """Analyse le prompt pour trouver des correspondances avec les README disponibles.
Logique: Match si â‰¥2 mots en commun (sauf si juste 'readme' + 'agent' â†’ besoin 3e mot).
Accepte majuscules/minuscules, espaces/underscores/sans-sÃ©paration."""
    def _extraire_mots_normalises(self, texte: str) -> List[str]:
      """Extrait les mots d'un texte en normalisant:
- Lowercase
- Remplace _ et espaces par rien
- Supprime extensions (.md)
- Filtre les mots vides (readme, agent, md)"""
    def _valider_match(self, mots_communs: set) -> bool:
      """Valide si un match est acceptable:
- Au moins 2 mots en commun
- Si seulement 'agent' est prÃ©sent, besoin d'au moins 1 autre mot"""
    def rechercher_documentation_technique(self, noms_fichiers: List[str]) -> List[Souvenir]:
      """Recherche ultra-rapide via Everything uniquement.
Pas de fallback manuel (trop lent)."""
    def recherche_hybride(self, intention: ResultatIntention) -> ResultatRecherche:
      """ExÃ©cute Vectoriel + Whoosh et fusionne via RRF en respectant la StratÃ©gie de PrioritÃ©."""
    def recherche_hybride_vectorielle(self, query_text: str, classification: Optional[ResultatIntention]=None, top_k: int=5) -> ResultatRecherche:
      """Fusionne Whoosh (Lexical) et Vecteur (SÃ©mantique).
Retourne un ResultatRecherche."""
    def recherche_whoosh_targeted(self, query_text: str, fichiers_candidats: List[str]=None, limit: int=10) -> List[Souvenir]:
      """Effectue la recherche Whoosh et convertit les rÃ©sultats en Souvenirs.
Accepte maintenant un argument 'limit' pour le RRF."""
    def update_index(self, contenu: str=None, type_memoire: str='persistante', sujet: str=None, action: str=None, categorie: str=None, session_id: str=None, message_turn: int=None, nouveau_fichier: str=None):
      """Met Ã  jour l'index Whoosh.
- Si 'nouveau_fichier' est fourni : Mise Ã  jour incrÃ©mentale (Rapide).
- Si 'nouveau_fichier' est None : RECONSTRUCTION COMPLÃˆTE (Maintenance)."""
    def rechercher_par_classification(self, sujet: Optional[Sujet]=None, action: Optional[Action]=None, categorie: Optional[Categorie]=None, tags: Optional[List[str]]=None, limite: int=20, depuis: Optional[datetime]=None) -> List[Dict]:
      """Recherche sÃ©mantique dans la mÃ©moire basÃ©e sur la classification.
ImplÃ©mente votre vision de "base de donnÃ©es sÃ©mantique".

Args:
    sujet: Filtrer par sujet (SECONDMIND, PSYCHOLOGIE, etc.)
    action: Filtrer par action (FAIRE, PENSER, PARLER)
    categorie: Filtrer par catÃ©gorie (CODER, ANALYSER, etc.)
    tags: Liste de tags Ã  rechercher
    limite: Nombre max de rÃ©sultats
    depuis: Filtrer depuis une date

Returns:
    Liste des interactions correspondantes"""
    def statistiques_semantiques(self, periode_jours: int=30) -> Dict[str, Any]:
      """GÃ©nÃ¨re des statistiques sur les interactions par classification.

Args:
    periode_jours: PÃ©riode d'analyse en jours
    
Returns:
    Dictionnaire avec statistiques dÃ©taillÃ©es"""
    def exporter_donnees_semantiques(self, format_export: str='json') -> str:
      """Exporte toutes les donnÃ©es de classification pour analyse externe.

Args:
    format_export: "json" ou "csv"
    
Returns:
    Chemin du fichier exportÃ©"""
    def get_stats(self) -> Dict:
      """Retourne les statistiques de l'index"""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Recherche.recherche_web (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Recherche\recherche_web.py)
  class RechercheWeb(AgentBase):
    def __init__(self, moteur_llm):
    def _generer_requetes(self, objectif: str, connaissances_actuelles: str='') -> List[str]:
      """GÃ©nÃ¨re des requÃªtes de recherche optimisÃ©es selon ce qu'on sait dÃ©jÃ ."""
    def _rechercher_urls(self, query: str) -> List[Dict]:
      """RÃ©cupÃ¨re les URLs via DuckDuckGo."""
    def _scraper_url(self, url: str) -> str:
      """TÃ©lÃ©charge et nettoie le contenu d'une page Web."""
    def _analyser_contenu(self, contenu: str, url: str, objectif: str) -> Dict:
      """Demande au LLM d'Ã©valuer la pertinence et d'extraire les infos.
Retourne un dict {score, extraction, suffisance}."""
    def executer_recherche_profonde(self, objectif: str) -> str:
      """Lance la boucle de recherche itÃ©rative.
Retourne une synthÃ¨se complÃ¨te."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_RechercheCode.RechercheCodeAdapter (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_RechercheCode\RechercheCodeAdapter.py)
  class RechercheCodeAdapter(AgentBase):
    """Adapter spÃ©cialisÃ© pour le RAG de code.
API stricte et minimale."""
    def __init__(self):
    def obtenir_contexte_code(self, question: str, top_k: int=8) -> Dict:
      """Fonction principale.
Retourne un dictionnaire contenant le contexte pertinent de code."""
    def resumer_contexte(self, result: Dict, max_len: int=20000) -> str:
      """Produit un rÃ©sumÃ© compact pour le LLM.
Limite la taille globale, supprime ce qui dÃ©passe."""
    def fournir_contexte_a_semi(self, question: str, top_k: int=8) -> str:
      """Interface haut-niveau :
1. Recherche
2. Compression
3. Retourne texte prÃªt pour injection dans le prompt"""
    def lire_fichier_source(self, nom_fichier: str) -> Optional[str]:
      """Lit le contenu brut d'un fichier source pour l'injecter dans le contexte.
Cherche le fichier Ã  partir de la racine du projet."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_RechercheCode.RechercheCodeExtractor (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_RechercheCode\RechercheCodeExtractor.py)
  class RechercheCodeExtractor(AgentBase):
    def __init__(self):
    def traiter_reponse_llm(self, texte_original: str) -> Tuple[str, List[Dict]]:
      """Analyse la rÃ©ponse du LLM.
Retourne :
1. Le texte nettoyÃ© (avec placeholders <ARTIFACT_CODE...>)
2. Une liste de dictionnaires 'artefacts' prÃªts Ã  Ãªtre sÃ©rialisÃ©s en JSON."""
    def analyser_fichier(self, filepath: str) -> Dict:
      """Analyse un fichier physique.
UtilisÃ© par le Gardien et l'AnalyseurCode."""
    def _analyser_contenu_code(self, content: str, langage: str, is_snippet: bool=False) -> Dict:
    def _analyser_python_hybride(self, content: str, is_snippet: bool) -> AnalyseContenu:
      """Structure de retour alignÃ©e sur le vocabulaire ContexteCode (classes, functions, etc.)"""
    def _get_base_name(self, node) -> str:
    def _analyser_javascript(self, content: str) -> AnalyseContenu:
    def _analyser_html(self, content: str) -> AnalyseContenu:
    def _analyser_css(self, content: str) -> AnalyseContenu:
    def _analyser_json(self, content: str) -> AnalyseContenu:
    def _analyser_generique(self, content: str) -> AnalyseContenu:
    def _extraire_concepts(self, content: str, extension: str) -> List[str]:

ğŸ“„ agentique.sous_agents_gouvernes.agent_RechercheCode.agent_RechercheCode (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_RechercheCode\agent_RechercheCode.py)
  class AgentRechercheCode(AgentBase):
    def __init__(self):
    def _charger_config(self) -> Dict:
    def _charger_architecture(self) -> Dict:
    def _indexer_chunks_offsets(self):
      """OPTIMISATION RAM :
Lit le fichier JSONL ligne par ligne et mÃ©morise l'offset (position octet)
de chaque chunk ID. Ne charge PAS le contenu en mÃ©moire."""
    def _get_chunk_content_by_id(self, chunk_id: str) -> Optional[Dict]:
      """RÃ©cupÃ¨re le contenu complet d'un chunk via son offset (Seek & Read).
TrÃ¨s rapide et Ã©conome en mÃ©moire."""
    def _charger_faiss(self):
    def _search_vector(self, query: str, top_k: int=8) -> List[Dict]:
      """Recherche vectorielle â†’ retourne les chunks complets (chargÃ©s Ã  la demande)."""
    def _trouver_modules_par_mots_cles(self, question: str) -> List[str]:
      """Recherche symbolique (Noms de modules/classes/fonctions).
Utilise l'architecture chargÃ©e en RAM (lÃ©ger)."""
    def _expand_dependencies(self, modules: List[str], depth: int=1) -> List[str]:
      """Ã‰tend la sÃ©lection aux modules dÃ©pendants (via outgoing_edges)."""
    def chercher_code(self, question: str, top_k: int=8) -> Dict:
      """Orchestrateur principal RAG Code."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_RechercheCode.outils.analyseur_de_code (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_RechercheCode\outils\analyseur_de_code.py)
  class AnalyseurCode(AgentBase):
    def __init__(self):
    def _charger_config(self) -> Dict:
    def _est_exclu(self, path_obj: Path) -> bool:
      """VÃ©rifie si le chemin complet contient un Ã©lÃ©ment interdit.
Analyse chaque partie du chemin (dossiers parents) et le nom du fichier."""
    def _purger_artefacts(self):
      """Supprime physiquement les anciens fichiers de sortie avant l'analyse.
Garantit que les scripts supprimÃ©s du disque disparaissent aussi des index."""
    def run(self):
    def _generer_vue_squelette(self, arch: Dict[str, Any]) -> str:
      """GÃ©nÃ¨re une vue textuelle enrichie de la structure des scripts.
Inclut signatures + docstrings pour chaque Ã©lÃ©ment.
Format optimisÃ© pour l'injection dans le prompt LLM."""
    def scanner_projet(self) -> Dict[str, Any]:
    def _analyse_python_file(self, path: Path) -> Dict[str, Any]:
      """Analyse enrichie avec extraction des appels et signatures"""
    def _extraire_attributs_classe(self, class_node: ast.ClassDef) -> Dict[str, str]:
      """Extrait les attributs d'instance depuis __init__ et les annotations.
Retourne {"agent_parole": "AgentParole", ...}"""
    def _deduire_type_depuis_valeur(self, value_node: ast.AST) -> Optional[str]:
      """DÃ©duit le type depuis une assignation (ex: AgentMemoire(...))"""
    def _analyser_fonction(self, func_node: ast.FunctionDef, attributs_map: Dict[str, str]) -> Dict[str, Any]:
      """Analyse complÃ¨te d'une fonction avec :
- Signature complÃ¨te
- Appels de fonctions (avec rÃ©solution self.xxx)
- Type de retour"""
    def _extraire_signature_complete(self, func_node: ast.FunctionDef) -> str:
      """Extrait la signature complÃ¨te avec annotations de types"""
    def _analyser_appels_fonction(self, func_node: ast.FunctionDef, attributs_map: Dict[str, str]) -> List[Dict[str, Any]]:
      """Extrait tous les appels de fonction avec rÃ©solution.

Ex: self.agent_parole.construire_prompt_llm(...)
  â†’ {"module": "agent_parole", "function": "construire_prompt_llm", "line": 326}"""
    def _resoudre_appel(self, call_node: ast.Call, attributs_map: Dict[str, str]) -> Optional[Dict[str, Any]]:
      """RÃ©sout un appel de fonction.

Exemples :
- self.agent_parole.construire_prompt_llm() 
  â†’ {"module": "AgentParole", "function": "construire_prompt_llm"}

- moteur_llm.generer_stream()
  â†’ {"module": "moteur_llm", "function": "generer_stream"}"""
    def _extraire_type_retour(self, func_node: ast.FunctionDef) -> Optional[str]:
      """Extrait le type de retour depuis l'annotation"""
    def _extraire_variables_utilisees(self, func_node: ast.FunctionDef) -> List[str]:
      """Extrait les attributs self.xxx utilisÃ©s dans la fonction"""
    def _extract_types_from_args(self, args: ast.arguments) -> Dict[str, str]:
    def generer_chunks(self, arch: Dict[str, Any]) -> List[ContexteCode]:
      """GÃ©nÃ¨re des chunks au format ContexteCode (dataclass standardisÃ©e)."""
    def _extraire_concepts(self, text: str) -> List[str]:
      """Extrait les concepts-clÃ©s depuis docstring/commentaires"""
    def _generer_resume_fonction(self, func_info: Dict) -> str:
      """GÃ©nÃ¨re un rÃ©sumÃ© d'une ligne pour la fonction"""
    def _read_text(self, path: Path) -> str:
    def _safe_name(self, node: ast.AST) -> str:
    def _module_name_from_path(self, py_path: Path) -> str:
    def construire_index_vectoriel(self, chunks: List[ContexteCode]) -> None:
      """Construit l'index FAISS Ã  partir des chunks ContexteCode"""

ğŸ“„ agentique.sous_agents_gouvernes.agent_RechercheCode.outils.outil_cycle_de_dependances (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_RechercheCode\outils\outil_cycle_de_dependances.py)
  def charger_architecture(path: Path=ARCH_PATH) -> Dict:
  def construire_graphe_dep(arch: Dict) -> Dict[str, Set[str]]:
    """Construit un graphe dirigÃ© des dÃ©pendances entre modules.

Les clÃ©s du graphe = noms complets des modules (agentique.Semi.agent_Semi)
Les arÃªtes = module A -> module B (A dÃ©pend de B)"""
  def trouver_cycles(graph: Dict[str, Set[str]]) -> List[List[str]]:
    """DÃ©tection de cycles par DFS.
Retourne une liste de cycles, chaque cycle Ã©tant une liste de modules."""
  def afficher_cycles(cycles: List[List[str]]) -> None:
  def valider_dependances() -> None:

ğŸ“„ agentique.sous_agents_gouvernes.agent_Reflexor.agent_Reflexor (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Reflexor\agent_Reflexor.py)
  class AgentReflexor(AgentBase):
    def __init__(self, agent_memoire: Optional['AgentMemoire']=None, moteur_llm: Optional['MoteurLLM']=None, moteur_vectoriel: Optional['MoteurVectoriel']=None, *args, **kwargs):
      """Initialise avec agents injectÃ©s par Semi"""
    def rechercher_cas_similaires(self, texte: str, top_k: int=5) -> List[Dict]:
      """Recherche dans la mÃ©moire vectorielle les interactions similaires."""
    def _analyser_cause_erreur(self, prompt_erreur: str, historique: List[str], cas_similaires: List[Dict]) -> str:
      """Phase 2 : Appel LLM nÂ°1 ("Pourquoi l'utilisateur s'est fÃ¢chÃ© ?")
Analyse l'historique pour trouver la cause racine de la frustration."""
    def lancer_analyse_gouvernance(self, prompt_erreur: str, historique: List[str]):
      """Orchestre la boucle rÃ©flexive complÃ¨te suite Ã  un signal '!!!'."""
    def _formatter_trace_reflexive(self, cas_analyse: Dict, correction: str) -> str:
    def creer_regle_auto_correction(self, cas_analyse: Dict) -> str:
      """GÃ©nÃ¨re la correction comportementale."""
    def enregistrer_feedback_etendu(self, prompt: str, reponse: str, score: float, mot_cle: str='gÃ©nÃ©ral') -> bool:
      """Enregistre un feedback utilisateur Ã©tendu (+1 mÃ©moire, +1 pertinence)."""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Structure.agent_Structure (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Structure\agent_Structure.py)
  class AgentStructure(AgentBase):
    def __init__(self, rapport_path: Optional[Path]=None, config_path: Optional[Path]=None):
    def generer_mapping(self):
      """GÃ©nÃ¨re le mapping via core_mapper"""
    def rapport_recent(self) -> Dict[str, Any]:
      """Retourne le dernier rapport"""
    def obtenir_statistiques(self) -> Dict[str, Any]:
      """Retourne des statistiques complÃ¨tes de l'agent Structure"""

ğŸ“„ agentique.sous_agents_gouvernes.agent_Structure.core_mapper (D:\rag_personnel\agentique\sous_agents_gouvernes\agent_Structure\core_mapper.py)
  def scan_structure(base_path):
  def save_log(mapping):
  def save_mapping(mapping):

ğŸ“„ agentique.test_filou (D:\rag_personnel\agentique\test_filou.py)
  def test():
